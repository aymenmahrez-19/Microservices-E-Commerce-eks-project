pipeline {
    agent any 

    environment {
        AWS_REGION = 'us-east-1'
        TERRAFORM_DIR = 'ecr-terraform'
        GIT_EMAIL = 'aymen.bendjaballah@univ-constantine2.dz'
        GIT_USER_NAME = 'aymenmahrez-19'
        GIT_REPO_NAME = 'Microservices-E-Commerce-eks-project'
        // Learner Lab specific
        LEARNER_LAB_ROLE = 'LabRole'
        LEARNER_LAB_INSTANCE_PROFILE = 'LabInstanceProfile'
    }

    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'üîß Select Terraform action (plan=preview, apply=create, destroy=delete)'
        )
        
        string(
            name: 'ECR_REPO_NAME',
            defaultValue: 'microservices-ecr',
            description: 'Name for ECR repository (lowercase, hyphens only)'
        )
        
        choice(
            name: 'AWS_REGION',
            choices: ['us-east-1', 'us-west-2'],
            description: 'AWS Region (Learner Lab supports us-east-1 and us-west-2)'
        )
        
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: '‚ö†Ô∏è Auto-approve apply/destroy (NOT RECOMMENDED for Learner Lab)'
        )
    }

    stages {
        stage('üîç Check Learner Lab Environment') {
            steps {
                script {
                    echo "üöÄ LEARNER LAB PIPELINE"
                    echo "================================"
                    echo "Action: ${params.ACTION}"
                    echo "ECR Repo: ${params.ECR_REPO_NAME}"
                    echo "Region: ${params.AWS_REGION}"
                    echo "Git User: ${env.GIT_USER_NAME}"
                    echo "================================"
                    
                    // Check AWS credentials
                    sh '''
                        echo "=== AWS Credentials Check ==="
                        aws configure set region $AWS_REGION
                        aws configure set output json
                        
                        if aws sts get-caller-identity; then
                            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
                            echo "‚úÖ AWS Account: $ACCOUNT_ID"
                        else
                            echo "‚ùå AWS credentials not working"
                            echo "In Learner Lab, ensure:"
                            echo "1. Jenkins EC2 has LabInstanceProfile attached"
                            echo "2. IAM role LabRole exists"
                        fi

                        echo "=== Terraform Check ==="
                        terraform --version
                    '''
                }
            }
        }

        stage('üì• Checkout Code') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/master']],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption', depth: 1, shallow: true]
                    ],
                    userRemoteConfigs: [[
                        url: 'https://github.com/aymenmahrez-19/Microservices-E-Commerce-eks-project.git'
                    ]]
                ])
                
                sh """
                    echo "=== Directory Structure ==="
                    ls -la
                    
                    if [ -d "$TERRAFORM_DIR" ]; then
                        echo "‚úÖ Terraform directory found: $TERRAFORM_DIR"
                        ls -la $TERRAFORM_DIR/
                    else
                        echo "‚ùå Terraform directory not found: $TERRAFORM_DIR"
                        echo "Creating basic Terraform configuration..."
                        mkdir -p $TERRAFORM_DIR
                    fi
                """
            }
        }

        stage('üîß Fix Terraform Files') {
            steps {
                dir(env.TERRAFORM_DIR) {
                    sh '''
                        echo "=== Fixing Terraform Files ==="
                        
                        for file in *.tr; do
                            if [ -f "$file" ]; then
                                new_name="${file%.tr}.tf"
                                echo "Renaming $file to $new_name"
                                mv "$file" "$new_name"
                            fi
                        done

                        if [ ! -f "main.tf" ] && [ ! -f "provider.tf" ]; then
                            echo "Creating basic Terraform configuration..."
                            
                            cat > provider.tf << EOF
provider "aws" {
  region = "$AWS_REGION"
  skip_credentials_validation = true
  skip_metadata_api_check     = true
}

data "aws_caller_identity" "current" {}
data "aws_region" "current" {}
EOF

                            cat > main.tf << EOF
resource "aws_ecr_repository" "main" {
  name = "${ECR_REPO_NAME}"
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  encryption_configuration {
    encryption_type = "AES256"
  }

  tags = {
    Name        = "${ECR_REPO_NAME}"
    Environment = "LearnerLab"
    CreatedBy   = "Jenkins"
    Project     = "Microservices-E-Commerce"
    CostCenter  = "Lab-Budget"
  }
}

resource "aws_ecr_lifecycle_policy" "main" {
  repository = aws_ecr_repository.main.name
  
  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last 5 images"
        selection = {
          tagStatus   = "any"
          countType   = "imageCountMoreThan"
          countNumber = 5
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 2
        description  = "Remove untagged images after 1 day"
        selection = {
          tagStatus   = "untagged"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = 1
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}

output "repository_url" {
  value = aws_ecr_repository.main.repository_url
}

output "repository_name" {
  value = aws_ecr_repository.main.name
}
EOF
                        fi

                        echo "=== Terraform Files ==="
                        ls -la *.tf 2>/dev/null || echo "No .tf files"
                    '''
                }
            }
        }

        stage('‚öôÔ∏è Terraform Init') {
            steps {
                dir(env.TERRAFORM_DIR) {
                    sh '''
                        echo "=== Terraform Init ==="
                        terraform init -input=false -reconfigure || true
                    '''
                }
            }
        }

        stage('üìä Terraform Plan') {
            when { expression { params.ACTION == 'plan' || params.ACTION == 'apply' } }
            steps {
                dir(env.TERRAFORM_DIR) {
                    sh """
                        echo "=== Terraform Plan ==="
                        terraform plan -var="repository_name=${params.ECR_REPO_NAME}" -var="region=${params.AWS_REGION}" -out=tfplan
                        echo "=== Plan Summary ==="
                        terraform show -no-color tfplan | head -n 20 || true
                    """
                    archiveArtifacts artifacts: '**/tfplan', fingerprint: true
                }
            }
        }

        stage('‚ö†Ô∏è Manual Approval (Apply/Destroy)') {
            when { expression { (params.ACTION == 'apply' || params.ACTION == 'destroy') && !params.AUTO_APPROVE } }
            steps {
                timeout(time: 2, unit: 'MINUTES') {
                    input(message: "Confirm ${params.ACTION} action?", ok: "Proceed")
                }
            }
        }

        stage('üöÄ Terraform Apply') {
            when { expression { params.ACTION == 'apply' } }
            steps {
                dir(env.TERRAFORM_DIR) {
                    sh """
                        echo "=== Terraform Apply ==="
                        terraform apply tfplan ${params.AUTO_APPROVE ? "-auto-approve" : ""}
                        terraform output -json || terraform output
                    """
                }
            }
        }

        stage('üóëÔ∏è Terraform Destroy') {
            when { expression { params.ACTION == 'destroy' } }
            steps {
                dir(env.TERRAFORM_DIR) {
                    sh """
                        echo "=== Terraform Destroy ==="
                        terraform destroy ${params.AUTO_APPROVE ? "-auto-approve" : ""}
                    """
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo "‚úÖ Pipeline completed successfully"
        }
        failure {
            echo "‚ùå Pipeline failed. Check logs"
        }
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }
}
