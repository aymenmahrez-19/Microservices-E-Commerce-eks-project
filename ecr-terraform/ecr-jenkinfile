pipeline {
    agent any

    environment {
        TERRAFORM_DIR = 'ecr-terraform'
        AWS_REGION    = 'us-east-1'
        GIT_EMAIL     = 'aymen.bendjaballah@univ-constantine2.dz'
        GIT_USER_NAME = 'aymenmahrez-19'
        GIT_REPO_NAME = 'Microservices-E-Commerce-eks-project'
    }

    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Terraform action: plan=preview, apply=create/update, destroy=delete'
        )

        string(
            name: 'AWS_REGION',
            defaultValue: 'us-east-1',
            description: 'AWS region'
        )

        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Enable auto-approve for apply/destroy'
        )
    }

    stages {
        stage('üîç AWS Credentials Check') {
            steps {
                sh '''
                    echo "=== AWS Credentials ==="
                    aws configure set region ${AWS_REGION}
                    aws configure set output json
                    aws sts get-caller-identity
                '''
            }
        }

        stage('üì• Checkout Code') {
            steps {
                checkout scm
                sh "ls -la ${TERRAFORM_DIR}/"
            }
        }

        stage('‚öôÔ∏è Terraform Init') {
            steps {
                dir(TERRAFORM_DIR) {
                    sh 'terraform init -input=false -reconfigure'
                }
            }
        }

        stage('üìä Terraform Plan') {
            when {
                expression { params.ACTION == 'plan' || params.ACTION == 'apply' }
            }
            steps {
                dir(TERRAFORM_DIR) {
                    sh """
                        terraform plan -var="aws_region=${AWS_REGION}" -out=tfplan
                        terraform show -no-color tfplan | head -n 20
                    """
                    archiveArtifacts artifacts: '**/tfplan', fingerprint: true
                }
            }
        }

        stage('üöÄ Terraform Apply') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                dir(TERRAFORM_DIR) {
                    sh """
                        terraform apply ${params.AUTO_APPROVE ? '-auto-approve tfplan' : 'tfplan'}
                        terraform output
                    """
                }
            }
        }

        stage('üóëÔ∏è Terraform Destroy') {
            when {
                expression { params.ACTION == 'destroy' }
            }
            steps {
                dir(TERRAFORM_DIR) {
                    sh """
                        terraform destroy ${params.AUTO_APPROVE ? '-auto-approve' : ''}
                    """
                }
            }
        }
    }

    post {
        always {
            dir(TERRAFORM_DIR) {
                archiveArtifacts artifacts: '*.tfstate, *.tfstate.backup', fingerprint: true, allowEmptyArchive: true
            }
        }
        failure { echo "‚ùå Pipeline failed" }
        success { echo "‚úÖ Pipeline completed successfully" }
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }
}
