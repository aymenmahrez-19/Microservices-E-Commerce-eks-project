pipeline {
    agent any

    environment {
        AWS_REGION = "us-east-1"
        AWS_ACCOUNT_ID = "851725560519"
        ECR_REPO_NAME = "aymen-load-generator"
        ECR_REPO_URL = "851725560519.dkr.ecr.us-east-1.amazonaws.com/aymen-load-generator"
        IMAGE_NAME = "loadgenerator"
        SERVICE_NAME = "load-generator"
        GIT_EMAIL = "aymen.bendjaballah@univ-constantine2.dz"
        GIT_USER_NAME = "aymenmahrez-19"
        GIT_REPO_NAME = "Microservices-E-Commerce-eks-project"
        // Learner Lab cost control
        MAX_ECR_IMAGES = "5"
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        retry(1)
    }

    stages {
        stage('üöÄ Initialize - Learner Lab') {
            steps {
                script {
                    echo """
                    ====================================
                    LOAD GENERATOR PIPELINE
                    ====================================
                    Service: ${SERVICE_NAME}
                    ECR: ${ECR_REPO_URL}
                    Image: ${IMAGE_NAME}
                    Build: ${BUILD_NUMBER}
                    Region: ${AWS_REGION}
                    Learner Lab Budget Aware
                    ====================================
                    """
                    
                    // Verify AWS configuration
                    sh '''
                        echo "=== Verifying AWS Configuration ==="
                        aws configure set region ${AWS_REGION}
                        aws configure set output json
                        
                        # Test AWS credentials
                        aws sts get-caller-identity && echo "‚úÖ AWS credentials working" || echo "‚ö†Ô∏è AWS credentials may need configuration"
                    '''
                }
            }
        }

        stage('üì• Checkout Code') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/master']],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption', depth: 1, shallow: true]
                    ],
                    userRemoteConfigs: [[
                        url: "https://github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git"
                    ]]
                ])
            }
        }

        stage('üîç Verify Dockerfile Exists') {
            steps {
                script {
                    sh """
                        echo "=== Checking Dockerfile ==="
                        
                        # Try multiple possible locations
                        POSSIBLE_PATHS=(
                            "src/${IMAGE_NAME}"
                            "${IMAGE_NAME}"
                            "src/load-generator"
                            "load-generator"
                        )
                        
                        DOCKERFILE_FOUND=""
                        DOCKERFILE_PATH=""
                        
                        for path in "\${POSSIBLE_PATHS[@]}"; do
                            if [ -d "\${path}" ]; then
                                echo "Checking directory: \${path}"
                                # Look for Dockerfile in this directory
                                if [ -f "\${path}/Dockerfile" ]; then
                                    DOCKERFILE_FOUND="\${path}/Dockerfile"
                                    DOCKERFILE_PATH="\${path}"
                                    break
                                elif [ -f "\${path}/src/Dockerfile" ]; then
                                    DOCKERFILE_FOUND="\${path}/src/Dockerfile"
                                    DOCKERFILE_PATH="\${path}/src"
                                    break
                                fi
                            fi
                        done
                        
                        if [ -n "\${DOCKERFILE_FOUND}" ]; then
                            echo "‚úÖ Dockerfile found at: \${DOCKERFILE_FOUND}"
                            echo "=== Dockerfile Preview ==="
                            head -20 "\${DOCKERFILE_FOUND}"
                            
                            # Check Dockerfile content
                            if grep -q "locust" "\${DOCKERFILE_FOUND}" || grep -q "python" "\${DOCKERFILE_FOUND}"; then
                                echo "‚úÖ Dockerfile appears to be for load generator"
                            else
                                echo "‚ö†Ô∏è Dockerfile may not be for load generator"
                            fi
                        else
                            echo "‚ùå Dockerfile not found in common locations"
                            echo "Creating minimal Dockerfile for load generator..."
                            
                            # Create directory if it doesn't exist
                            mkdir -p "src/${IMAGE_NAME}/src"
                            DOCKERFILE_PATH="src/${IMAGE_NAME}/src"
                            
                            # Create proper load generator Dockerfile
                            cat > "\${DOCKERFILE_PATH}/Dockerfile" << 'EOF'
FROM python:3.11-slim

WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY locustfile.py .

# Expose Locust UI port
EXPOSE 8089

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:8089/ || exit 1

# Run Locust
CMD ["locust", "--host=http://frontend:80", "--web-port=8089"]
EOF
                            
                            # Create requirements.txt
                            cat > "\${DOCKERFILE_PATH}/requirements.txt" << 'EOF'
locust==2.17.0
requests==2.31.0
EOF
                            
                            # Create sample locustfile.py
                            cat > "\${DOCKERFILE_PATH}/locustfile.py" << 'EOF'
from locust import HttpUser, task, between

class WebsiteUser(HttpUser):
    wait_time = between(1, 5)
    
    @task
    def index(self):
        self.client.get("/")
    
    @task(3)
    def view_products(self):
        self.client.get("/api/products")
    
    @task(2)
    def view_cart(self):
        self.client.get("/api/cart")
EOF
                            
                            echo "‚úÖ Created load generator Dockerfile and related files"
                            echo "DOCKERFILE_PATH=\${DOCKERFILE_PATH}" > dockerfile.env
                        fi
                        
                        # If we found a Dockerfile, save its path
                        if [ -n "\${DOCKERFILE_PATH}" ]; then
                            echo "DOCKERFILE_PATH=\${DOCKERFILE_PATH}" > dockerfile.env
                        else
                            # Default fallback
                            echo "DOCKERFILE_PATH=src/${IMAGE_NAME}/src" > dockerfile.env
                        fi
                    """
                    
                    // Load the Dockerfile path
                    load 'dockerfile.env'
                }
            }
        }

        stage('üê≥ Docker Build') {
            steps {
                script {
                    sh """
                        echo "=== Building Docker Image ==="
                        echo "Path: ${DOCKERFILE_PATH}"
                        
                        if [ ! -d "${DOCKERFILE_PATH}" ]; then
                            echo "‚ùå Directory not found: ${DOCKERFILE_PATH}"
                            echo "Creating it..."
                            mkdir -p "${DOCKERFILE_PATH}"
                        fi
                        
                        cd "${DOCKERFILE_PATH}"
                        
                        echo "=== Directory Contents ==="
                        ls -la
                        
                        # Clean previous builds
                        docker system prune -f 2>/dev/null || true
                        
                        # Build with multiple tags
                        docker build \\
                            -t ${IMAGE_NAME}:\${BUILD_NUMBER} \\
                            -t ${IMAGE_NAME}:latest \\
                            -t ${IMAGE_NAME}:learner-lab-\${BUILD_NUMBER} \\
                            --build-arg BUILDKIT_INLINE_CACHE=1 \\
                            .
                        
                        echo "‚úÖ Image built successfully"
                        echo "=== Built Images ==="
                        docker images | grep ${IMAGE_NAME}
                    """
                }
            }
        }

        stage('üîê Login to ECR') {
            steps {
                sh """
                    echo "=== Logging into ECR ==="
                    aws ecr get-login-password --region ${AWS_REGION} | \\
                    docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
                    echo "‚úÖ Logged into ECR"
                """
            }
        }

        stage('üì§ Push to ECR') {
            steps {
                script {
                    sh """
                        echo "=== Pushing to ECR ==="
                        
                        # Create ECR repository if it doesn't exist
                        if ! aws ecr describe-repositories --repository-names ${ECR_REPO_NAME} --region ${AWS_REGION} 2>/dev/null; then
                            echo "‚ö†Ô∏è ECR repository doesn't exist, creating it..."
                            aws ecr create-repository \\
                                --repository-name ${ECR_REPO_NAME} \\
                                --region ${AWS_REGION} \\
                                --image-tag-mutability MUTABLE \\
                                --image-scanning-configuration scanOnPush=false \\
                                --tags Key=Environment,Value=LearnerLab Key=Service,Value=load-generator
                            echo "‚úÖ ECR repository created"
                        else
                            echo "‚úÖ ECR repository already exists"
                        fi
                        
                        # Tag images
                        docker tag ${IMAGE_NAME}:\${BUILD_NUMBER} ${ECR_REPO_URL}:\${BUILD_NUMBER}
                        docker tag ${IMAGE_NAME}:latest ${ECR_REPO_URL}:latest
                        
                        # Push to ECR
                        echo "Pushing images to ECR..."
                        docker push ${ECR_REPO_URL}:\${BUILD_NUMBER}
                        docker push ${ECR_REPO_URL}:latest
                        
                        echo "‚úÖ Pushed: ${ECR_REPO_URL}:\${BUILD_NUMBER}"
                        echo "‚úÖ Pushed: ${ECR_REPO_URL}:latest"
                        
                        # Apply lifecycle policy for Learner Lab cost control
                        echo "=== Applying lifecycle policy ==="
                        cat > lifecycle-policy.json << EOF
{
    "rules": [
        {
            "rulePriority": 1,
            "description": "Keep only last ${MAX_ECR_IMAGES} images",
            "selection": {
                "tagStatus": "any",
                "countType": "imageCountMoreThan",
                "countNumber": ${MAX_ECR_IMAGES}
            },
            "action": {
                "type": "expire"
            }
        }
    ]
}
EOF
                        
                        aws ecr put-lifecycle-policy \\
                            --repository-name ${ECR_REPO_NAME} \\
                            --region ${AWS_REGION} \\
                            --lifecycle-policy-text file://lifecycle-policy.json 2>/dev/null || echo "Lifecycle policy updated or already exists"
                        
                        # List current images in ECR
                        echo "=== Current ECR Images ==="
                        aws ecr list-images \\
                            --repository-name ${ECR_REPO_NAME} \\
                            --region ${AWS_REGION} \\
                            --query "imageIds[].imageTag" \\
                            --output text 2>/dev/null | tr '\\t' '\\n' | sort || echo "No images yet"
                    """
                }
            }
        }

        stage('üìù Update Kubernetes YAML') {
            steps {
                script {
                    dir('kubernetes-files') {
                        def yamlFile = "loadgenerator.yaml"
                        
                        sh """
                            echo "=== Updating Kubernetes YAML ==="
                            
                            # Check if YAML file exists
                            if [ ! -f "${yamlFile}" ]; then
                                echo "‚ö†Ô∏è ${yamlFile} not found, creating template..."
                                cat > ${yamlFile} << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loadgenerator
  namespace: default
  labels:
    app: loadgenerator
    environment: learner-lab
spec:
  replicas: 1
  selector:
    matchLabels:
      app: loadgenerator
  template:
    metadata:
      labels:
        app: loadgenerator
    spec:
      containers:
      - name: loadgenerator
        image: ${ECR_REPO_URL}:latest
        ports:
        - containerPort: 8089
        env:
        - name: LOCUST_MODE
          value: "standalone"
        - name: TARGET_HOST
          value: "http://frontend:80"
        - name: LOCUST_USERS
          value: "10"
        - name: LOCUST_SPAWN_RATE
          value: "1"
        - name: LOCUST_RUN_TIME
          value: "5m"
        - name: SERVICE_NAME
          value: "loadgenerator"
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "250m"
            memory: "256Mi"
        command: ["locust"]
        args:
          - "--host=\$(TARGET_HOST)"
          - "--users=\$(LOCUST_USERS)"
          - "--spawn-rate=\$(LOCUST_SPAWN_RATE)"
          - "--run-time=\$(LOCUST_RUN_TIME)"
          - "--web-port=8089"
          - "--headless"
        livenessProbe:
          httpGet:
            path: /
            port: 8089
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 8089
          initialDelaySeconds: 10
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: loadgenerator
  namespace: default
spec:
  selector:
    app: loadgenerator
  ports:
  - port: 8089
    targetPort: 8089
  type: ClusterIP
EOF
                                echo "‚úÖ Created ${yamlFile}"
                            else
                                echo "‚úÖ Found ${yamlFile}"
                            fi
                            
                            # Update image tag
                            sed -i "s|image:.*|image: ${ECR_REPO_URL}:${BUILD_NUMBER}|g" ${yamlFile}
                            
                            echo "=== Updated Image Tag ==="
                            grep "image:" ${yamlFile}
                            echo ""
                            echo "=== YAML Preview ==="
                            head -30 ${yamlFile}
                        """
                    }
                }
            }
        }

        stage('üîÄ Commit & Push to Git') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'my-git-pattoken', variable: 'GIT_TOKEN')]) {
                        sh """
                            echo "=== Committing to Git ==="
                            
                            # Configure git
                            git config --global user.email "${GIT_EMAIL}"
                            git config --global user.name "${GIT_USER_NAME}"
                            
                            # Ensure we're on master branch
                            git checkout master 2>/dev/null || git checkout -b master
                            
                            # Add and commit
                            git add kubernetes-files/loadgenerator.yaml
                            git commit -m "LearnerLab: Update ${SERVICE_NAME} to build-${BUILD_NUMBER}" || echo "No changes to commit"
                            
                            # Push to GitHub
                            git push https://${GIT_USER_NAME}:${GIT_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            
                            echo "‚úÖ Changes pushed to GitHub"
                        """
                    }
                }
            }
        }

        stage('üí∞ Learner Lab Budget Summary') {
            steps {
                script {
                    echo """
                    ===========================================
                    üí∞ LEARNER LAB BUDGET SUMMARY
                    ===========================================
                    Service: ${SERVICE_NAME}
                    ECR: ${ECR_REPO_URL}:${BUILD_NUMBER}
                    
                    ‚úÖ SUCCESS: Load generator built and pushed
                    
                    üìä ESTIMATED COST:
                    - ECR Storage: ~\\$0.02/month (200MB image)
                    - Lifecycle: Keeps only ${MAX_ECR_IMAGES} images
                    
                    üéØ DEPLOYMENT COMMAND:
                    kubectl apply -f kubernetes-files/loadgenerator.yaml
                    
                    üîç ACCESS LOAD TEST UI:
                    kubectl port-forward svc/loadgenerator 8089:8089
                    Open: http://localhost:8089
                    
                    üßπ CLEANUP (When done):
                    kubectl delete -f kubernetes-files/loadgenerator.yaml
                    ===========================================
                    """
                }
            }
        }
    }

    post {
        always {
            // Cleanup to save space in Learner Lab
            sh '''
                echo "=== Cleaning up ==="
                docker system prune -f 2>/dev/null || true
                rm -f dockerfile.env lifecycle-policy.json 2>/dev/null || true
            '''
            
            // Archive artifacts
            archiveArtifacts artifacts: 'kubernetes-files/*.yaml', fingerprint: true, allowEmptyArchive: true
        }
        
        success {
            echo """
            ‚úÖ LOAD GENERATOR PIPELINE SUCCESS!
            ====================================
            Image: ${ECR_REPO_URL}:${BUILD_NUMBER}
            Build: ${BUILD_NUMBER}
            
            To deploy to EKS:
            kubectl apply -f kubernetes-files/loadgenerator.yaml
            
            To access Locust UI:
            kubectl port-forward svc/loadgenerator 8089:8089
            Then open: http://localhost:8089
            
            Next: Build other microservices or deploy to EKS!
            ====================================
            """
        }
        
        failure {
            echo """
            ‚ùå LOAD GENERATOR PIPELINE FAILED
            ====================================
            Check logs above for specific error.
            
            Common issues:
            1. Dockerfile not found
            2. ECR repository permissions
            3. AWS credentials not configured
            
            Debug commands:
            - find . -name "Dockerfile" -type f
            - ls -la src/loadgenerator/
            - docker images | grep loadgenerator
            ====================================
            """
        }
        
        cleanup {
            cleanWs()
        }
    }
}